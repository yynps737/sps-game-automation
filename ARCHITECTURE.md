# 《杖剑传说》游戏自动化框架 技术架构设计书

## 一、架构哲学

**核心原则**：数据驱动、约定优于配置、关注点分离。

**设计理念**：框架即约束，约束即自由。

## 二、系统架构

### 2.1 分层架构
```
表现层 → 应用层 → 领域层 → 基础设施层
  ↓         ↓         ↓           ↓
PyQt6   Task/Flow   Core/FSM   ADB/OpenCV
```

### 2.2 核心抽象

**Game**：游戏实体，包含识别器、控制器、状态机。

**Scene**：场景定义，持有元素集合、转换规则、验证条件。

**Action**：原子操作，封装点击、滑动、等待、识别。

**Task**：任务编排，组合Action序列，支持条件分支。

**State**：状态节点，定义进入条件、执行逻辑、退出路径。

## 三、技术栈定义

**主框架**：Python 3.11 + PyQt6 + asyncio

**图像栈**：OpenCV 4.9 + NumPy + Pillow

**性能层**：Cython + pybind11 (按需)

**配置层**：YAML + JSON Schema

**通信层**：ADB Protocol + WebSocket

## 四、模块设计

### 4.1 引擎层 (core.engine)

**ImageEngine**
- 模板匹配：多尺度、多旋转、容错阈值
- 特征识别：ORB特征点、FLANN匹配器
- OCR识别：PaddleOCR中文优化
- 缓存策略：LRU + 模板预加载

**ControlEngine**
- 坐标映射：设备无关坐标系
- 手势生成：贝塞尔曲线 + 高斯扰动
- 延迟策略：泊松分布 + 上下文感知

**StateEngine**
- 有限状态机：分层状态 + 并发区域
- 转换条件：谓词逻辑 + 优先级队列
- 异常处理：降级策略 + 自动恢复

### 4.2 驱动层 (core.driver)

**ADBDriver**
- 连接池：多设备管理 + 自动重连
- 命令队列：批处理 + 流控
- 异常隔离：超时重试 + 熔断机制

**CaptureDriver**  
- 截图策略：screencap / minicap / scrcpy
- 差分检测：帧间对比 + ROI优化
- 压缩传输：WebP格式 + 增量更新

### 4.3 游戏适配层 (games.*)

**配置驱动**
```yaml
# 声明式配置，非命令式代码
scenes:
  main_menu:
    elements: [daily_task, dungeon, shop]
    transitions: 
      daily_task: daily_scene
    validation: element_exists('menu_flag')
```

**任务定义**
```yaml
# 任务即数据，数据即任务
daily_energy:
  schedule: "0 */6 * * *"
  precondition: game.energy < 100
  actions:
    - goto: main_menu
    - click: energy_button
    - wait_for: energy_collected
```

### 4.4 扩展机制

**插件协议**
- 生命周期：init → start → execute → stop → destroy
- 事件总线：发布订阅 + 事件过滤
- 依赖注入：自动装配 + 作用域管理

**热更新**
- 模板热加载：文件监控 + 增量更新
- 配置热重载：版本对比 + 平滑切换
- 脚本热更新：importlib.reload + 状态保持

## 五、性能设计

### 5.1 并发模型
- 主线程：GUI事件循环
- 工作线程：图像识别 + 状态机
- IO线程：ADB通信 + 文件操作
- 协程池：异步任务调度

### 5.2 内存管理
- 对象池：Action、Image、Result复用
- 弱引用：场景、元素、模板缓存
- 内存映射：大图像文件共享

### 5.3 优化策略
- 延迟加载：按需初始化游戏模块
- 预测执行：基于历史的动作预测
- 批量处理：相似识别任务合并

## 六、可靠性设计

### 6.1 容错机制
- 识别容错：多策略降级 + 置信度阈值
- 操作容错：重试机制 + 补偿动作
- 状态容错：检查点 + 状态恢复

### 6.2 监控体系
- 性能监控：FPS、CPU、内存、延迟
- 行为监控：操作频率、成功率、异常率
- 业务监控：任务完成度、资源获取量

## 七、安全设计

### 7.1 防检测策略
- 行为仿真：鼠标轨迹、点击分布、操作节奏
- 时间管理：作息模拟、疲劳度、随机休息
- 特征混淆：设备指纹、分辨率、网络延迟

### 7.2 数据安全
- 配置加密：敏感信息AES加密
- 通信加密：ADB over TLS
- 日志脱敏：账号、密码、坐标混淆

## 八、工程规范

### 8.1 目录约定
```
core/     # 框架核心，游戏无关
games/    # 游戏实现，框架无关  
plugins/  # 扩展插件，双向无关
tests/    # 测试用例，镜像结构
```

### 8.2 命名约定
- 类：PascalCase，名词
- 函数：snake_case，动词
- 常量：UPPER_CASE
- 配置：kebab-case

### 8.3 接口约定
- 输入验证：类型注解 + 运行时检查
- 输出规范：Result[T] | Error
- 异步约定：async/await + Future

## 九、开发路线

### Phase 1：核心框架（2周）
引擎层 → 驱动层 → 基础状态机

### Phase 2：游戏适配（1周）
场景定义 → 任务脚本 → 模板采集

### Phase 3：界面开发（1周）
主窗口 → 任务管理 → 日志系统

### Phase 4：优化迭代（2周）
性能优化 → 稳定性 → 扩展性

## 十、架构演进

**横向扩展**：新游戏 = 新配置 + 新模板

**纵向优化**：瓶颈模块 → C++重写

**云端化**：本地引擎 → RPC调用 → 云端执行

---

*架构是演进的，不是设计的。*

*代码是生长的，不是堆砌的。*

*系统是活的，持续进化。*